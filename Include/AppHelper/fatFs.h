/*---------------------------------------------------------------------------/
/  FatFs - FAT file system module include file  R0.07e       (C)ChaN, 2009
/----------------------------------------------------------------------------/
/ FatFs module is a generic FAT file system module for small embedded systems.
/ This is a free software that opened for education, research and commercial
/ developments under license policy of following trems.
/
/  Copyright (C) 2009, ChaN, all right reserved.
/
/ * The FatFs module is a free software and there is NO WARRANTY.
/ * No restriction on use. You can use, modify and redistribute it for
/   personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
/ * Redistributions of source code must retain the above copyright notice.
/----------------------------------------------------------------------------*/

#ifndef FATFS
#define FATFS	0x007E

#include "fatConfig.h"		/* FatFs configuration options */

#if FATFS != FS_CONFIG
#error Wrong configuration file (fatFs.h).
#endif


/* DBCS code ranges and SBCS extend char conversion table */

#if FS_CODE_PAGE == 932	/* Japanese Shift-JIS */
#define _DF1S	0x81	/* DBC 1st byte range 1 start */
#define _DF1E	0x9F	/* DBC 1st byte range 1 end */
#define _DF2S	0xE0	/* DBC 1st byte range 2 start */
#define _DF2E	0xFC	/* DBC 1st byte range 2 end */
#define _DS1S	0x40	/* DBC 2nd byte range 1 start */
#define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
#define _DS2S	0x80	/* DBC 2nd byte range 2 start */
#define _DS2E	0xFC	/* DBC 2nd byte range 2 end */

#elif FS_CODE_PAGE == 936	/* Simplified Chinese GBK */
#define _DF1S	0x81
#define _DF1E	0xFE
#define _DS1S	0x40
#define _DS1E	0x7E
#define _DS2S	0x80
#define _DS2E	0xFE

#elif FS_CODE_PAGE == 949	/* Korean */
#define _DF1S	0x81
#define _DF1E	0xFE
#define _DS1S	0x41
#define _DS1E	0x5A
#define _DS2S	0x61
#define _DS2E	0x7A
#define _DS3S	0x81
#define _DS3E	0xFE

#elif FS_CODE_PAGE == 950	/* Traditional Chinese Big5 */
#define _DF1S	0x81
#define _DF1E	0xFE
#define _DS1S	0x40
#define _DS1E	0x7E
#define _DS2S	0xA1
#define _DS2E	0xFE

#elif FS_CODE_PAGE == 437	/* U.S. (OEM) */
#define _DF1S	0
#define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}

#elif FS_CODE_PAGE == 720	/* Arabic (OEM) */
#define _DF1S	0
#define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}

#elif FS_CODE_PAGE == 737	/* Greek (OEM) */
#define _DF1S	0
#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}

#elif FS_CODE_PAGE == 775	/* Baltic (OEM) */
#define _DF1S	0
#define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}

#elif FS_CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
#define _DF1S	0
#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}

#elif FS_CODE_PAGE == 852	/* Latin 2 (OEM) */
#define _DF1S	0
#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}

#elif FS_CODE_PAGE == 855	/* Cyrillic (OEM) */
#define _DF1S	0
#define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}

#elif FS_CODE_PAGE == 857	/* Turkish (OEM) */
#define _DF1S	0
#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}

#elif FS_CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
#define _DF1S	0
#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}

#elif FS_CODE_PAGE == 862	/* Hebrew (OEM) */
#define _DF1S	0
#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}

#elif FS_CODE_PAGE == 866	/* Russian (OEM) */
#define _DF1S	0
#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}

#elif FS_CODE_PAGE == 874	/* Thai (OEM, Windows) */
#define _DF1S	0
#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}

#elif FS_CODE_PAGE == 1250 /* Central Europe (Windows) */
#define _DF1S	0
#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}

#elif FS_CODE_PAGE == 1251 /* Cyrillic (Windows) */
#define _DF1S	0
#define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}

#elif FS_CODE_PAGE == 1252 /* Latin 1 (Windows) */
#define _DF1S	0
#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}

#elif FS_CODE_PAGE == 1253 /* Greek (Windows) */
#define _DF1S	0
#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}

#elif FS_CODE_PAGE == 1254 /* Turkish (Windows) */
#define _DF1S	0
#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}

#elif FS_CODE_PAGE == 1255 /* Hebrew (Windows) */
#define _DF1S	0
#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}

#elif FS_CODE_PAGE == 1256 /* Arabic (Windows) */
#define _DF1S	0
#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}

#elif FS_CODE_PAGE == 1257 /* Baltic (Windows) */
#define _DF1S	0
#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}

#elif FS_CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
#define _DF1S	0
#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}

#elif FS_CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
#define _DF1S	0

#else
#error Unknown code page

#endif	// FS_CODE_PAGE



/* Character code support macros */

#define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
#define IsLower(c)	(((c)>='a')&&((c)<='z'))

#if _DF1S		/* DBCS configuration */

#ifdef _DF2S	/* Two 1st byte areas */
#define IsDBCS1(c)	(((PFbyte)(c) >= _DF1S && (PFbyte)(c) <= _DF1E) || ((PFbyte)(c) >= _DF2S && (PFbyte)(c) <= _DF2E))
#else			/* One 1st byte area */
#define IsDBCS1(c)	((PFbyte)(c) >= _DF1S && (PFbyte)(c) <= _DF1E)
#endif

#ifdef _DS3S	/* Three 2nd byte areas */
#define IsDBCS2(c)	(((PFbyte)(c) >= _DS1S && (PFbyte)(c) <= _DS1E) || ((PFbyte)(c) >= _DS2S && (PFbyte)(c) <= _DS2E) || ((PFbyte)(c) >= _DS3S && (PFbyte)(c) <= _DS3E))
#else			/* Two 2nd byte areas */
#define IsDBCS2(c)	(((PFbyte)(c) >= _DS1S && (PFbyte)(c) <= _DS1E) || ((PFbyte)(c) >= _DS2S && (PFbyte)(c) <= _DS2E))
#endif

#else			/* SBCS configuration */

#define IsDBCS1(c)	0
#define IsDBCS2(c)	0

#endif /* _DF1S */

/* Definitions corresponds to multi-partition */
#if FS_MULTI_PARTITION		/* Multiple partition configuration */

typedef struct{
	PFbyte pd;	/* Physical drive# */
	PFbyte pt;	/* Partition # (0-3) */
}FsPartition;

extern
const FsPartition Drives[];			/* Logical drive# to physical location conversion table */
#define LD2PD(drv) (Drives[drv].pd)	/* Get physical drive# */
#define LD2PT(drv) (Drives[drv].pt)	/* Get partition# */

#else						/* Single partition configuration */

#define LD2PD(drv) (drv)	/* Physical drive# is equal to the logical drive# */
#define LD2PT(drv) 0		/* Always mounts the 1st partition */

#endif	// #if FS_MULTI_PARTITION


/* Definitions corresponds to multiple sector size */
#if FS_MAX_SS == 512		/* Single sector size */
#define	SS(fs)	512U
#elif FS_MAX_SS == 1024 || FS_MAX_SS == 2048 || FS_MAX_SS == 4096	/* Multiple sector size */
#define	SS(fs)	((fs)->s_size)
#else
#error Sector size must be 512, 1024, 2048 or 4096.
#endif



/** Type of file name on FatFs API */
#if FS_LFN_UNICODE && FS_USE_LFN
	#define XCHAR	PFword 		/* Unicode */
#else
	#define XCHAR	PFchar 		/* SBCS, DBCS */
#endif

/** File system object structure */
typedef struct{
	PFbyte	fs_type;	/**< FAT sub type */
	PFbyte 	drive; 		/**< Pointer to block device */
	PFbyte	csize;		/**< Number of sectors per cluster */
	PFbyte	n_fats;		/**< Number of FAT copies */
	PFbyte	wflag;		/**< win[] dirty flag (1:must be written back) */
	PFbyte	fsi_flag;	/**< fsinfo dirty flag (1:must be written back) */
	PFword	id;			/**< File system mount ID */
	PFword	n_rootdir;	/**< Number of root directory entries (0 on FAT32) */
#if FS_REENTRANT
	_SYNC_t	sobj;		/**< Identifier of sync object */
#endif	// #if FS_REENTRANT
#if FS_MAX_SS != 512
	PFword	s_size;		/**< Sector size */
#endif
#if !FS_READONLY
	PFdword	last_clust;	/**< Last allocated cluster */
	PFdword	free_clust;	/**< Number of free clusters */
	PFdword	fsi_sector;	/**< fsinfo sector */
#endif	// #if !FS_READONLY
#if FS_RPATH
	PFdword	cdir;		/**< Current directory (0:root)*/
#endif	// #if FS_RPATH
	PFdword	sects_fat;	/**< Sectors per fat */
	PFdword	max_clust;	/**< Maximum cluster# + 1. Number of clusters is max_clust - 2 */
	PFdword	fatbase;	/**< FAT start sector */
	PFdword	dirbase;	/**< Root directory start sector (Cluster# on FAT32) */
	PFdword	database;	/**< Data start sector */
	PFdword	winsect;	/**< Current sector appearing in the win[] */
	PFbyte	win[FS_MAX_SS];/**< Disk access window for Directory/FAT */
} FatFs;

/** Directory object structure */
typedef struct{
	FatFs* fs;		/**< Pointer to the owner file system object */
	PFword	id;			/**< Owner file system mount ID */
	PFword	index;		/**< Current read/write index number */
	PFdword	sclust;		/**< Table start cluster (0:Static table) */
	PFdword	clust;		/**< Current cluster */
	PFdword	sect;		/**< Current sector */
	PFbyte*	dir;		/**< Pointer to the current SFN entry in the win[] */
	PFbyte*	fn;			/**< Pointer to the SFN (in/out) {file[8],ext[3],status[1]} */
#if (FS_USE_LFN != 0)
	PFword*	lfn;		/**< Pointer to the LFN working buffer */
	PFword	lfn_idx;	/**< Last matched LFN index number (0xFFFF:No LFN) */
#endif	// #if (FS_USE_LFN != 0)
}FsDir;

/** File object structure */
typedef struct{
	FatFs*	fs;		/**< Pointer to the owner file system object */
	PFword	id;			/**< Owner file system mount ID */
	PFbyte	flag;		/**< File status flags */
	PFbyte	csect;		/**< Sector address in the cluster */
	PFdword	fptr;		/**< File R/W pointer */
	PFdword	fsize;		/**< File size */
	PFdword	org_clust;	/**< File start cluster */
	PFdword	curr_clust;	/**< Current cluster */
	PFdword	dsect;		/**< Current data sector */
#if !FS_READONLY
	PFdword	dir_sect;	/**< Sector containing the directory entry */
	PFbyte*	dir_ptr;	/**< Pointer to the directory entry in the window */
#endif	// #if !FS_READONLY
#if !FS_TINY
	PFbyte	buf[FS_MAX_SS];/**< File R/W buffer */
#endif	// #if !FS_TINY
} FsFile;

/** File status structure */
typedef struct{
	PFdword	fsize;		/**< File size */
	PFword	fdate;		/**< Last modified date */
	PFword	ftime;		/**< Last modified time */
	PFbyte	fattrib;	/**< Attribute */
	PFchar	fname[13];	/**< Short file name (8.3 format) */
#if FS_USE_LFN
	XCHAR*	lfname;		/**< Pointer to the LFN buffer */
	PFsdword 	lfsize;	/**< Size of LFN buffer [chrs] */
#endif
} FsFileInfo;


/**
 * The fsMount function registers/unregisters a work area to the FatFs module.
 * The work area must be given to the each volume with this function prior to use any other file function.
 * To unregister a work area, specify a NULL to the FileSystemObject, and then the work area can be discarded.
 * This function always succeeds regardless of the drive status. No media access is occured in this function.
 * It only clears the given work area and registers its address to the internal table.
 * The volume mount process is performed on first file access after fsMount function or media change.
 *
 * \param drive Logical drive number (0-9) to register/unregister the work area.
 * \param fs Pointer to the work area (file system object) to be registered.
 *
 * \return Status. Return status is always success.
 */
PFEnStatus fsMount(PFbyte drive, FatFs *fs);

/**
 * After fsFileOpen function succeeded, the file object is valid.
 * The file object is used for subsequent read/write functions to identify the file.
 * When close an open file object, use fsFileClose function.
 * If the modified file is not closed, the file data can be collapsed.
 *
 * \param fp Pointer to the file object structure to be created.
 * \param path Pointer to a null-terminated string that specifies the file name to create or open.
 * \param mode Specifies the type of access and open method for the file. It is specified by a combination of following flags.
 *
 * \return Status
 */
PFEnStatus fsFileOpen(FsFile *fp, const XCHAR *path, PFbyte mode);

/**
 * The function reads \a btr bytes from the file represented by file object \a fp.
 * The file pointer of the file object increases in number of bytes read.
 * After the function succeeded, *br (BytesRead) should be checked to detect the end of file.
 * If *br (BytesRead)< btr (BytesToRead), it means the file pointer reached
 * end of the file during read operation.
 *
 * \param fp Pointer to the open file object.
 * \param pBuf Pointer to the buffer to store read data.
 * \param btr Number of bytes to read.
 * \param br Pointer to the PFdword variable to return number of bytes read.
 * 			The value is always valid after the function call regardless of the result.
 *
 * \return Status
 */
PFEnStatus fsFileRead(FsFile *fp, void *pBuf, PFdword btr, PFdword *br);

/**
 * The function writes \a btw bytes to the file represented by file object \a fp.
 * Changes are saved and file size is increased when the file is closed.
 * After the function succeeded, *bw (BytesWritten) should be checked to detect if the disk is full.
 * If *bw (BytesWritten)< btw (BytesToWrite), it means volume got full during the write operation.
 *
 * \param fp Pointer to the open file object.
 * \param pBuf Pointer to the data to be written.
 * \param btr Number of bytes to write.
 * \param br Pointer to the PFdword variable to return number of bytes written.
 * 			The value is always valid after the function call regardless of the result.
 *
 * \return Status
 *
 * \note Available when FS_READONLY = 0.
 */
#if (FS_READONLY == 0)
PFEnStatus fsFileWrite(FsFile *fp, const void *pBuf, PFdword btw, PFdword *bw);
#endif	// #if (FS_READONLY == 0)

/**
 * The fsFileSync function flushes the cached information of writing file and increases the file size.
 * It is similar to 'save' option provided in the text editors.
 * The fsFileSync function performs the same process as fsFileClose function but the file is left opened
 * and can continue read/write/seek operations to the file. In other words, the difference between those functions
 * is that the file object is invalidated or not.
 *
 * \param fp Pointer to the open file object to be flushed.
 *
 * \return Status
 *
 * \note Available when FS_READONLY = 0.
 */
#if (FS_READONLY == 0)
PFEnStatus fsFileSync(FsFile *fp);
#endif	// #if (FS_READONLY == 0)

/**
 * The fsFileClose function closes an open file. If any data has been written to the file,
 * the cached information of the file is written back to the disk. After the function succeeded,
 * the file object is no longer valid and it can be discarded.
 *
 * \param fp Pointer to the open file object to be closed.
 *
 * \return Status
 */
PFEnStatus fsFileClose(FsFile *fp);

/**
 * The fsChangeDrive function changes the current drive. Note that the current drive is retained in a
 * static variable so that it also affects other tasks that using the file functions.
 *
 * \param drv Specifies the logical drive number to be set as the current drive.
 *
 * \return Status
 *
 * \note Available when FS_RPATH >= 1.
 */
#if (FS_RPATH >= 1)
PFEnStatus fsChangeDrive(PFbyte drv);
#endif	// #if (FS_RPATH >= 1)

/**
 * The fsChangeDirectory function changes the current directory of the logical drive.
 * The current directory of a drive is initialized to the root directory when the drive is auto-mounted.
 * Note that the current directory is retained in the each file system object so that it also affects
 * other tasks that using the drive.
 *
 * \param path Pointer to the null-terminated string that specifies a directory to go
 *
 * \return Status
 *
 * \note Available when FS_RPATH >= 1.
 */
#if (FS_RPATH >= 1)
PFEnStatus fsChangeDirectory(const XCHAR *path);
#endif	// #if (FS_RPATH >= 1)

/**
 * The f_lseek function moves the file read/write pointer of an open file. The offset can be specified
 * in only origin from top of the file. When an offset above the file size is specified in write mode,
 * the file size is increased to the offset and the data in the expanded area is undefined. This is suitable
 * to create a large file quickly, for fast write operation. After the f_lseek function succeeded,
 * current read/write pointer should be checked in order to make sure the read/write pointer has been moved
 * correctly. In case of the current read/write pointer is not the expected value, either of followings has been occurred.
 * End of file: The specified Offset was clipped at end of the file because the file has been opened in read-only mode.
 * Disk full: There is insufficient free space on the volume to expand the file size.
 *
 * \param fp Pointer to open file object
 * \param ofs Location in number of bytes from start of file, to move file pointer
 *
 * \return Status
 *
 * \note Available when FS_MINIMIZE <= 2
 */
#if (FS_MINIMIZE <= 2)
PFEnStatus fsFileSeek(FsFile *fp, PFdword ofs);
#endif // #if (FS_MINIMIZE <= 2)

/**
 * The f_opendir function opens an existing directory and creates the directory object for subsequent calls.
 * The directory object structure can be discarded at any time without any procedure.
 *
 * \param dj Pointer to the blank directory object to be created
 * \param path Pointer to the null-terminated string that specifies the directory name to be opened
 *
 * \return Status
 *
 * \note Available when FS_MINIMIZE <= 1
 */
#if (FS_MINIMIZE <= 1)
PFEnStatus fsDirOpen(FsDir* dj,	const XCHAR* path);
#endif // #if (FS_MINIMIZE <= 1)

/**
 * The fsDirReadEntry function reads directory entries in sequence. All items in the directory can be read by
 * calling f_readdir function repeatedly. When all directory entries have been read and no item to read,
 * the function returns a null string into fname[] member without any error.
 * When a null pointer is given to the FileInfo, the read index of the directory object will be rewinded.
 * When LFN feature is enabled, lfname and lfsize in the file information structure must be initialized
 * with valid value prior to use the fsDirReadEntry function. The lfname is a pointer to the string buffer
 * to return the long file name. The lfsize is the size of the string buffer in bytes. If either the size
 * of read buffer or LFN working buffer is insufficient for the LFN or the object has no LFN, a null string
 * will be returned to the LFN read buffer.
 * When relative path feature is enabled (FS_RPATH == 1), "." and ".." entries are not filtered out.
 *
 * \param dj Pointer to open directory object
 * \param fno Pointer to file information structure to store read item
 *
 * \return Status
 *
 * \note Available when FS_MINIMIZE <= 1
 */
#if (FS_MINIMIZE <= 1)
PFEnStatus fsDirReadEntry(FsDir* dj, FsFileInfo *fno);
#endif // #if (FS_MINIMIZE <= 1)

/**
 * The f_stat gets the size, timestamp and attribute of a file or directory.
 *
 * \param path Pointer to the null-terminated string that specifies the file or directory to get its information.
 * \param fno Pointer to the blank FsFileInfo structure to store the information.
 *
 * \return Status
 *
 * \note Available when FS_MINIMIZE = 0
 */
#if (FS_MINIMIZE == 0)
PFEnStatus fsGetFileStatus(const XCHAR *path, FsFileInfo *fno);
#endif	// #if (FS_MINIMIZE == 0)

/**
 * The f_getfree function gets number of free clusters on the drive. The member csize in the file system object
 * is reflecting number of sectors per cluster, so that the free space in unit of sector can be calculated with this.
 * When FSInfo structure on FAT32 volume is not in sync, this function can return an incorrect free cluster count.
 *
 * \param path Pointer to the null-terminated string that specifies the logical drive.
 * \param nclst Pointer to the PFdword variable to store number of free clusters.
 * \param fatfs Pointer to pointer that to store a pointer to the corresponding file system object.
 *
 * \return Status
 *
 * \note Available when FS_READONLY = 0 and FS_MINIMIZE = 0.
 */
#if ((FS_READONLY == 0) && (FS_MINIMIZE == 0))
PFEnStatus fsGetFreeClusters(const XCHAR *path, PFdword* nclst, FatFs** fatfs);
#endif	// #if ((FS_READONLY == 0) && (FS_MINIMIZE = 0))

/**
 *The fsFileTruncate function truncates the file size to the current file read/write point.
 * The This function has no effect if the file read/write pointer is already pointing end of the file.
 *
 * \param fp Pointer to the open file object to be truncated.
 *
 * \return Status
 *
 * \note Available when FS_READONLY = 0 and FS_MINIMIZE = 0.
 */
#if ((FS_READONLY == 0) && (FS_MINIMIZE == 0))
PFEnStatus fsFileTruncate(FsFile* fp);
#endif	// #if ((FS_READONLY == 0) && (FS_MINIMIZE == 0))

/**
 * The fsFileDelete function removes a file or directory.
 * The object to be removed should satisfy the terms mentioned below:
 * 1. The object must not have read-only attribute.
 * 2. If the directory is to be removed, it should be empty and should not be current directory.
 * 3. The file should not be opened.
 *
 * \param path Pointer to the null-terminated string that specifies an object to be removed.
 *
 * \return Status
 *
 * \note Available when FS_READONLY = 0 and FS_MINIMIZE = 0.
 */
#if ((FS_READONLY == 0) && (FS_MINIMIZE == 0))
PFEnStatus fsFileDelete(const XCHAR* path);
#endif	// #if ((FS_READONLY == 0) && (FS_MINIMIZE == 0))

/**
 * The fsDirCreate creates a new directory.
 *
 * \param path Pointer to the null-terminated string that specifies the directory name to create.
 *
 * \retrun Status
 *
 * \note Available when FS_READONLY = 0 and FS_MINIMIZE = 0.
 */
#if ((FS_READONLY == 0) && (FS_MINIMIZE == 0))
PFEnStatus fsDirCreate(const XCHAR* path);
#endif	// #if ((FS_READONLY == 0) && (FS_MINIMIZE == 0))

/**
 * The f_chmod function changes the attribute of a file or directory.
 *
 * \param path
 * \param value Attribute flags to be set in one or more combination of the following flags.
 * The specified flags are set and others are cleared.
 * 		--------------------------------
 * 		|	Attribute	|	Description	|
 * 		---------------------------------
 * 		|	AM_RDO		|	Read only	|
 * 		|	AM_ARC		|	Achieved	|
 * 		|	AM_SYS		|	System		|
 * 		|	AM_HID		|	Hidden		|
 * 		---------------------------------
 * \param mask Attribute mask that specifies which attributes to change.
 * 			Only the specified attributes are set or cleared.
 *
 * 	\return Status
 *
 * \note Available when FS_READONLY = 0 and FS_MINIMIZE = 0.
 */
#if ((FS_READONLY == 0) && (FS_MINIMIZE == 0))
PFEnStatus fsFileChangeAttrib(const XCHAR* path, PFbyte value, PFbyte mask);
#endif	// #if ((FS_READONLY == 0) && (FS_MINIMIZE == 0))

/**
 * The fsFileChangeTimestamp function changes the timestamp of a file or directory.
 *
 * \param path Pointer to the null-terminated string that specifies a file or directory to be changed.
 * \param fno Pointer to the file information structure that has a timestamp to be set in member fdate and ftime.
 * 			Do not care any other members.
 *
 * \return Status
 *
 * \note Available when FS_READONLY = 0 and FS_MINIMIZE = 0.
 */
#if ((FS_READONLY == 0) && (FS_MINIMIZE == 0))
PFEnStatus fsFileChangeTimestamp(const XCHAR* path, const FsFileInfo* fno);
#endif	// #if ((FS_READONLY == 0) && (FS_MINIMIZE == 0))

/**
 * fsFileRename renames file or directory. The object also be moved to other directory.
 * The should not be opened while renaming.
 *
 * \param path_old Pointer to a null-terminated string specifies the old object name to be renamed.
 * \param path_new Pointer to a null-terminated string specifies the new object name without drive number.
 *
 * \retrun Status
 *
 * \note Available when FS_READONLY = 0 and FS_MINIMIZE = 0.
 */
#if ((FS_READONLY == 0) && (FS_MINIMIZE == 0))
PFEnStatus fsFileRename(const XCHAR* path_old, const XCHAR* path_new);
#endif	// #if ((FS_READONLY == 0) && (FS_MINIMIZE == 0))

/**
 * The f_forward function reads the data from the file and forward it to the outgoing stream without
 * data buffer. This is suitable for small memory system because it does not require any data buffer
 * at application module. The file pointer of the file object increases in number of bytes forwarded.
 * In case of *ByteFwd (\a bf) < ByteToFwd (\a btr) without error, it means the requested bytes could not be transferred
 * due to end of file or stream goes busy during data transfer.
 *
 * \param fp Pointer to the open file object.
 * \param func Pointer to the user-defined data streaming function.
 * \param btr Number of bytes to forward (32 bit value).
 * \param bf Pointer to the PFdword variable to return number of bytes forwarded.
 *
 * \return Status
 *
 * \note Available when FS_USE_FORWARD = 1 and FS_TINY = 1.
 */
#if ((FS_USE_FORWARD == 1) && (FS_TINY == 1))
PFEnStatus fsFileForward(FsFile *fp, PFdword (*func)(const PFbyte*,PFdword), PFdword btr, PFdword *bf);
#endif	// #if ((FS_USE_FORWARD == 1) && (FS_TINY == 1))

/**
 * The fsFormat function creates an FAT file system on the logical drive. When FDISK is specified,
 * a primary partition occupies the entire disk space is created and then an FAT volume is created on
 * the partition. When SFD is specified, the FAT volume starts from the first sector of the physical drive.
 * If the logical drive is being bound to any partition (1-4) by multiple partition feature (MULTI_PARTITION),
 * the FAT volume is created into the specified partition. In this case, the second argument is ignored.
 *
 * \param drv Logical drive number (0-9) to be formatted.
 * \param partition Specifies partitioning rule, 0: FDISK, 1: SFD. This argument is ignored on some case.
 * \param allocsize Force the allocation unit (cluster) size in unit of byte.
 * 				The value must be power of 2 and between the sector size and 128 * sector size.
 * 				When a zero is given, the cluster size is determined depends on the volume size.
 *
 * \note Available when FS_READOLNY = 0, FS_USE_MKFS = 1 and MULTI_PARTITION = 2.
 */
#if ((FS_READONLY == 0) && (FS_USE_MKFS == 1) && (MULTI_PARTITION == 2))
PFEnStatus fsFormat(PFbyte drv, PFbyte partition,	PFword allocsize);
#endif	// #if ((FS_READOLNY == 0) (FS_USE_MKFS == 1) && (MULTI_PARTITION == 2))

#if (FS_USE_STRFUNC != 0)
/**
 * The fsFileGetString function is a wrapper function of fsFileRead.
 * The read operation continues until a '\n' is stored, reached end of the file or the buffer
 * is filled with Size - 1 characters. The read string is terminated with a '\0'.
 * When no character to read or any error occurred during read operation, fsFileGetString returns
 * a null pointer. The end of file and error status can be examined with f_eof() and f_error() macros.
 *
 * \param pBuf Pointer to read buffer to store the read string.
 * \param len Size of the read buffer in bytes.
 * \param fil Pointer to the open file object structure.
 *
 * \return Success: \a pBuf, Failure: null pointer.
 *
 * \note Available when FS_USE_STRFUNC != 0.
 * When FS_USE_STRFUNC = 2, '\r's contained in the file are stripped out.
 */
PFchar* fsFileGetString(PFchar* pBuf,	PFsdword len, FsFile* fil);

/**
 * The fsFilePutChar function puts a character to the file. It is a wrapper function of fsFileWrite.
 *
 * \param chr Character to be put.
 * \param fil Pointer to the open file object structure.
 *
 * \return Success: 1, Failure: -1.
 *
 * \note Available when FS_READONLY = 0 and FS_USE_STRFUNC != 0.
 * WhenFS_USE_STRFUNC = 2, '\n' is converted to "\r\n.
 */
PFsdword fsFilePutChar(PFsdword chr, FsFile* fil);

/**
 * The fsFilePutString function writes a string to the file. It is a wrapper function of fsFilePutChar.
 *
 * \param str Pointer to the null terminated string to be written. The null character will not be written.
 * \param fil Pointer to the open file object structure.
 *
 * \return Success: Number of characters written, Failure: -1
 *
 * \note Available when FS_READONLY = 0 and FS_USE_STRFUNC != 0.
 * When FS_USE_STRFUNC = 2, '\n' is converted to "\r\n.
 */
PFsdword fsFilePutString(const PFchar* str, FsFile* fil);

/**
 * The fsFilePrint function writes formatted string to the file.
 * It is a wrapper function of fsFilePutChar and fsFilePutString.
 *
 * \param file Pointer to the open file object structure.
 * \param str Pointer to the null terminated format string.
 * \param ... Optional arguments.
 *
 * \note Available when FS_USE_MKFS is defined, FS_READONLY = 0 and FS_USE_STRFUNC != 0.
 * When FS_USE_STRFUNC = 2, '\n' is converted to "\r\n.
 */
#if (FS_USE_MKFS == 1)
PFsdword fsFilePrint(FsFile* fil, const PFchar* str, ...);
#endif	// #if (FS_USE_MKFS == 1)

#define FS_CHECK_EOF(fp) (((fp)->fptr == (fp)->fsize) ? 1 : 0)
#define FS_CHECK_ERROR(fp) (((fp)->flag & FA__ERROR) ? 1 : 0)

#ifndef EOF
	/** End of file	*/
	#define EOF -1
#endif	// #ifndef EOF
#endif	// (FS_USE_STRFUNC != 0)



/*--------------------------------------------------------------*/
/* User defined functions                                       */

/* Real time clock */
#if !FS_READONLY
PFdword get_fattime (void);	/* 31-25: Year(0-127 org.1980), 24-21: Month(1-12), 20-16: Day(1-31) */
							/* 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) */
#endif	// #if !FS_READONLY

/* Unicode - OEM code conversion */
#if FS_USE_LFN
PFword ff_convert (PFword, PFdword);
PFword ff_wtoupper (PFword);
#endif	// #if FS_USE_LFN

/* Sync functions */
#if FS_REENTRANT
PFEnBoolean ff_cre_syncobj(PFbyte, _SYNC_t*);
PFEnBoolean ff_del_syncobj(_SYNC_t);
PFEnBoolean ff_req_grant(_SYNC_t);
void ff_rel_grant(_SYNC_t);
#endif	// #if FS_REENTRANT



/*--------------------------------------------------------------*/
/* Flags and offset address                                     */


/** File access control and file status flags (FsFile.flag) */
#define	FA_READ				0x01
#define	FA_OPEN_EXISTING	0x00
#if (FS_READONLY == 0)
#define	FA_WRITE			0x02
#define	FA_CREATE_NEW		0x04
#define	FA_CREATE_ALWAYS	0x08
#define	FA_OPEN_ALWAYS		0x10
#define FA__WRITTEN			0x20
#define FA__DIRTY			0x40
#endif	// #if (FS_READONLY == 0)
#define FA__ERROR			0x80


/* FAT sub type (FatFs.fs_type) */
#define FS_FAT12	1
#define FS_FAT16	2
#define FS_FAT32	3


/** File attribute bits for directory entry */
#define	AM_RDO	0x01	/**< Read only */
#define	AM_HID	0x02	/**< Hidden */
#define	AM_SYS	0x04	/**< System */
#define	AM_VOL	0x08	/**< Volume label */
#define AM_LFN	0x0F	/**< LFN entry */
#define AM_DIR	0x10	/**< Directory */
#define AM_ARC	0x20	/**< Archive */
#define AM_MASK	0x3F	/**< Mask of defined bits */


/* FatFs refers the members in the FAT structures with byte offset instead
/ of structure member because there are incompatibility of the packing option
/ between various compilers. */

#define BS_jmpBoot			0
#define BS_OEMName			3
#define BPB_BytsPerSec		11
#define BPB_SecPerClus		13
#define BPB_RsvdSecCnt		14
#define BPB_NumFATs			16
#define BPB_RootEntCnt		17
#define BPB_TotSec16		19
#define BPB_Media			21
#define BPB_FATSz16			22
#define BPB_SecPerTrk		24
#define BPB_NumHeads		26
#define BPB_HiddSec			28
#define BPB_TotSec32		32
#define BS_55AA				510

#define BS_DrvNum			36
#define BS_BootSig			38
#define BS_VolID			39
#define BS_VolLab			43
#define BS_FilSysType		54

#define BPB_FATSz32			36
#define BPB_ExtFlags		40
#define BPB_FSVer			42
#define BPB_RootClus		44
#define BPB_FSInfo			48
#define BPB_BkBootSec		50
#define BS_DrvNum32			64
#define BS_BootSig32		66
#define BS_VolID32			67
#define BS_VolLab32			71
#define BS_FilSysType32		82

#define	FSI_LeadSig			0
#define	FSI_StrucSig		484
#define	FSI_Free_Count		488
#define	FSI_Nxt_Free		492

#define MBR_Table			446

#define	DIR_Name			0
#define	DIR_Attr			11
#define	DIR_NTres			12
#define	DIR_CrtTime			14
#define	DIR_CrtDate			16
#define	DIR_FstClusHI		20
#define	DIR_WrtTime			22
#define	DIR_WrtDate			24
#define	DIR_FstClusLO		26
#define	DIR_FileSize		28
#define	LDIR_Ord			0
#define	LDIR_Attr			11
#define	LDIR_Type			12
#define	LDIR_Chksum			13
#define	LDIR_FstClusLO		26



/*--------------------------------*/
/* Multi-byte word access macros  */

#if FS_WORD_ACCESS == 1	/* Enable word access to the FAT structure */
#define	LD_WORD(ptr)		(PFword)(*(PFword*)(PFbyte*)(ptr))
#define	LD_DWORD(ptr)		(PFdword)(*(PFdword*)(PFbyte*)(ptr))
#define	ST_WORD(ptr,val)	*(PFword*)(PFbyte*)(ptr)=(PFword)(val)
#define	ST_DWORD(ptr,val)	*(PFdword*)(PFbyte*)(ptr)=(PFdword)(val)
#else					/* Use byte-by-byte access to the FAT structure */
#define	LD_WORD(ptr)		(PFword)(((PFword)*(PFbyte*)((ptr)+1)<<8)|(PFword)*(PFbyte*)(ptr))
#define	LD_DWORD(ptr)		(PFdword)(((PFdword)*(PFbyte*)((ptr)+3)<<24)|((PFdword)*(PFbyte*)((ptr)+2)<<16)|((PFword)*(PFbyte*)((ptr)+1)<<8)|*(PFbyte*)(ptr))
#define	ST_WORD(ptr,val)	*(PFbyte*)(ptr)=(PFbyte)(val); *(PFbyte*)((ptr)+1)=(PFbyte)((PFword)(val)>>8)
#define	ST_DWORD(ptr,val)	*(PFbyte*)(ptr)=(PFbyte)(val); *(PFbyte*)((ptr)+1)=(PFbyte)((PFword)(val)>>8); *(PFbyte*)((ptr)+2)=(PFbyte)((PFdword)(val)>>16); *(PFbyte*)((ptr)+3)=(PFbyte)((PFdword)(val)>>24)
#endif


#endif /* FATFS */
